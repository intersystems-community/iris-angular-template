Include %sySecurity

Class AngularTemplate.Installer
{

Parameter RoleName = "AngularTemplate";

ClassMethod SetupBASE()
{
	set vars("Environment") = "BASE"
	set vars("SourceNamespace") = $namespace
	do ..setup(.vars)
}

ClassMethod SetupTEST()
{
	set vars("Environment") = "TEST"
	set vars("SourceNamespace") = $namespace
	do ..setup(.vars)
}

/// Manifest Definition.
XData MyManifest [ XMLNamespace = INSTALLER ]
{
<Manifest>

<Var Name="Namespace" Value="angular-template"/>
<If Condition='##class(%File).DirectoryExists("/database")'>
<Var Name="CodeDBDir" Value="/database/${Namespace}-CODE/"/>
<Var Name="DataDBDir" Value="/database/${Namespace}-DATA/"/>
<Var Name="ConfigDBDir" Value="/database/${Namespace}-CONFIG/"/>
<Else>
<Var Name="CodeDBDir" Value="${MGRDIR}${Namespace}-CODE/"/>
<Var Name="DataDBDir" Value="${MGRDIR}${Namespace}-DATA/"/>
<Var Name="ConfigDBDir" Value="${MGRDIR}${Namespace}-CONFIG/"/>
</Else>
</If>

<!-- Initialize databases -->
<Namespace Name="${SourceNamespace}" Create="no">
<If Condition='##class(%File).DirectoryExists("${CodeDBDir}")'>
<Database Name="${Namespace}-CODE" Dir="${CodeDBDir}" Create="no" InitialSize="10" ExpansionSize="10" />
<Else>
<Database Name="${Namespace}-CODE" Dir="${CodeDBDir}" Create="yes" InitialSize="10" ExpansionSize="10" />
</Else>
</If>
<If Condition='##class(%File).DirectoryExists("${DataDBDir}")'>
<Database Name="${Namespace}-DATA" Dir="${DataDBDir}" Create="no" InitialSize="10" ExpansionSize="10" />
<Else>
<Database Name="${Namespace}-DATA" Dir="${DataDBDir}" Create="yes" InitialSize="10" ExpansionSize="10" />
</Else>
</If>
<If Condition='##class(%File).DirectoryExists("${ConfigDBDir}")'>
<Database Name="${Namespace}-CONFIG" Dir="${ConfigDBDir}" Create="no" InitialSize="10" ExpansionSize="10" />
<Else>
<Database Name="${Namespace}-CONFIG" Dir="${ConfigDBDir}" Create="yes" InitialSize="10" ExpansionSize="10" />
</Else>
</If>
</Namespace>

<!-- Change data, code directories on namespace  -->
<Namespace Name="${Namespace}" Ensemble="0" Code="${Namespace}-CODE" Data="${Namespace}-DATA">
<Configuration>
<GlobalMapping Global="Config" From="${Namespace}-CONFIG" />
<GlobalMapping Global="Sources" From="${Namespace}-CONFIG" />
<GlobalMapping Global="SYS" From="${Namespace}-CONFIG" />
</Configuration>
</Namespace>

<Namespace Name="${SourceNamespace}" Create="no">

<!-- Install ZPM -->
<Invoke Class="AngularTemplate.Installer" Method="InstallZPM" />
</Namespace>

<Namespace Name="${Namespace}" Create="no">
<!-- ZPM load -->
<Invoke Class="AngularTemplate.Installer" Method="ZPMLoad" />
<Invoke Class="AngularTemplate.Installer" Method="RunSourceControlSetup" />
<Invoke Class="AngularTemplate.Installer" Method="SetupCodeTidy" />
</Namespace>

<Namespace Name="${SourceNamespace}" Create="no">

<!-- Configure Source Control -->
<!---->
</Namespace>
</Manifest>
}

ClassMethod SetupUAT()
{
	set vars("Environment") = "UAT"
	set vars("SourceNamespace") = $namespace
	do ..setup(.vars)
}

ClassMethod SetupLIVE()
{
	set vars("Environment") = "LIVE"
	set vars("SourceNamespace") = $namespace
	do ..setup(.vars)
}

/// This is a method generator whose code is generated by XGL.
ClassMethod setup(ByRef pVars, pLogLevel As %Integer = 3, pInstaller As %Installer.Installer, pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
	// Let our XGL document generate code for this method.
	quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "MyManifest")
}

ClassMethod InstallZPM(force As %Boolean = 0) As %Status
{
	if $$$comClassDefined("%ZPM.PackageManager") && 'force {
		quit $$$OK
	}
	if $$$isUNIX {
		do $zf(-100, "", "mkdir", "-p", "/tmp/deps")
		do $zf(-100, "", "wget", "-q", "https://pm.community.intersystems.com/packages/zpm/latest/installer", "-O", "/tmp/deps/zpm.xml")
		set sc = $system.OBJ.Load("/tmp/deps/zpm.xml", "ck")
	} else {
		do ##class(%File).CreateDirectoryChain("C:\Temp\")
		do $zf(-100, "/STDOUT=""C:\Temp\zpm.xml""", "curl", "https://pm.community.intersystems.com/packages/zpm/latest/installer")
		set sc = $system.OBJ.Load("C:\Temp\zpm.xml", "ck")
	}
	write !
	quit sc
}

ClassMethod ZPMLoad()
{
	set cmd = "load " _ ^Sources _ " -dev -verbose"
	write "zpm " _ $$$QUOTE(cmd)
	do ##class(%ZPM.PackageManager).Shell(cmd)
}

ClassMethod ToggleIRISLIBReadOnly(readOnly As %Boolean) As %Boolean
{
	if '$system.Security.Check($$$AdminManageResourceName, $$$PermUseName) {
		// No-op; let the user do whatever their current permissions happen to allow, rather than definitely failing at this stage.
		quit readOnly
	}

	set return = readOnly
	set directory = ##class(%SYS.Namespace).GetPackageDest($namespace, "%Studio")
	new $namespace
	set $namespace = "%SYS"
	set database = ##class(SYS.Database).%OpenId($piece(directory, "^", 2), , .tSC)
	$$$ThrowOnError(tSC)
	if (database.ReadOnly '= readOnly) {
		set return = database.ReadOnly
		set database.ReadOnly = readOnly
		$$$ThrowOnError(database.%Save())
	}
	quit return
}

ClassMethod SetCSSToUTF8()
{
	write !, "Setting:",
	"^%SYS(""CSP"",""MimeFileClassify"",""CSS"")=$lb(""text/css"",0,""utf-8"")",
	"^%SYS(""CSP"",""MimeFileClassify"",""HTML"")=$lb(""text/html"",0,""utf-8"")",
	"^%SYS(""CSP"",""MimeFileClassify"",""JS"")=$lb(""application/javascript"",0,""utf-8"")"
	set ^%SYS("CSP", "MimeFileClassify", "CSS") = $listbuild("text/css", 0, "utf-8")
	set ^%SYS("CSP", "MimeFileClassify", "HTML") = $listbuild("text/html", 0, "utf-8")
	set ^%SYS("CSP", "MimeFileClassify", "JS") = $listbuild("application/javascript", 0, "utf-8")
}

ClassMethod ApplySecurityChanges(webApplication As %String, roleName As %String = {..#RoleName})
{
	set oldNS = $namespace
	new $namespace
	set $namespace = "%SYS"
	
	// Find the namespace-default routine DB
	set grantPermissions = ""
	$$$ThrowOnError(##class(Config.Namespaces).Get(oldNS, .nsProps))
	for defaultDB = nsProps("Routines"), nsProps("Globals") {
		$$$ThrowOnError(##class(Config.Databases).Get(defaultDB, .dbProps))
		set db = ##class(SYS.Database).%OpenId(dbProps("Directory"), , .sc)
		$$$ThrowOnError(sc)
		if $get(dbResource) = db.ResourceName {
			// On second iteration, found same database
			// Reset grantPermissions
			set grantPermissions = ""
		}
		set dbResource = db.ResourceName

		// Is there public READ permission on the namespace-default routine DB?
		$$$ThrowOnError(##class(Security.Resources).Get(dbResource, .resourceProps))
		set grantPermission = $case(defaultDB, nsProps("Globals"):"RW", :"R")
		if $data(resourceProps("PublicPermission"), publicPermission) # 2 && (publicPermission [ grantPermission) {
			// No need to do anything else if there's public R permission
			continue
		}
		set grantPermissions = grantPermissions _ $listbuild(dbResource _ ":" _ grantPermission)
	}

	if grantPermissions = "" {
		quit
	}

	// Create role granting R permission on namespace-default routine DB resource
	// This is the least-access means to be able to use the REST handler class
	// in unauthenticated mode
	set roleProps("Description") = "Role granting " _ $listtostring(grantPermissions, " and ")
	set roleProps("Resources") = $listtostring(grantPermissions)
	set roleProps("GrantedRoles") = ""
	if ##class(Security.Roles).Exists(roleName) {
		write !, "Updating role: ", roleName
		$$$ThrowOnError(##class(Security.Roles).Modify(roleName, .roleProps))
	} else {
		write !, "Creating role: ", roleName
		$$$ThrowOnError(##class(Security.Roles).Create(roleName, roleProps("Description"), roleProps("Resources"), roleProps("GrantedRoles")))
	}
	$$$ThrowOnError(##class(Security.Applications).Get(webApplication, .props))
	set props("MatchRoles") = ":" _ roleName
	$$$ThrowOnError(##class(Security.Applications).Modify(webApplication, .props))
}

ClassMethod RemoveSecurityChanges(roleName As %String = {..#RoleName})
{
	set oldNS = $namespace
	new $namespace
	set $namespace = "%SYS"
	
	try {
		if ##class(Security.Roles).Exists(roleName) {
			write !, "Removing role: ", roleName
			$$$ThrowOnError(##class(Security.Roles).Delete(roleName))
		}
	} catch e {
		write !, "Error occurred cleaning up security objects: "
		write $system.Status.GetErrorText(e.AsStatus())
	}
}

ClassMethod RunSourceControlSetup(namespace As %String = {$Namespace}, environment As %String = "BASE", sourceNamespace As %String = {$Namespace})
{
	set sc = $$$OK
	
	// Copy this class to the target namespace
	if (sourceNamespace '= namespace) {
		merge ^|namespace|oddDEF($classname()) = ^oddDEF($classname())
	}
	
	
	try {
		new $namespace
		set $namespace = namespace
		if (sourceNamespace '= namespace) {
			$$$ThrowOnError($system.OBJ.Compile($classname(), "ck-d"))
		}

		// Make IRISLIB R/W; need to leave it this way for JSON compilation...
		set old = ..ToggleIRISLIBReadOnly(0)
		
		// Set up source control
		// TODO: Refactor once https://github.com/intersystems/git-source-control/issues/262 is addressed
		$$$ThrowOnError(##class(%Studio.SourceControl.Interface).SourceControlClassSet("SourceControl.Git.Extension"))
		set mappingsNode = ##class(SourceControl.Git.Utils).MappingsNode()
		if '$data(@mappingsNode) {
			do ##class(SourceControl.Git.Utils).SetDefaultMappings(mappingsNode)
			write !, "Configured default mappings for classes, routines, and include files. You can customize these in the global:", !?5, mappingsNode
		}

		set ^SYS("SourceControl","Git","settings","gitBinPath")=""
		set ^SYS("SourceControl","Git","settings","mappings","CLS","*")="cls/"
		set ^SYS("SourceControl","Git","settings","mappings","CLS","UnitTest")="test/"
		set ^SYS("SourceControl","Git","settings","mappings","INC","*")="inc/"
		set ^SYS("SourceControl","Git","settings","mappings","MAC","*")="rtn/"
		set ^SYS("SourceControl","Git","settings","namespaceTemp")="/tmp/angular-template/"
		set ^SYS("SourceControl","Git","settings","percentClassReplace")=""
		set ^SYS("SourceControl","Git","settings","pullEventClass")="SourceControl.Git.PullEventHandler.Default"
		set ^SYS("SourceControl","Git","settings","settingsUIReadOnly")=0
		set ^SYS("SourceControl","Git","settings","ssh","privateKeyFile")=""
		set ^SYS("SourceControl","Git","settings","user","irisowner","gitUserEmail")="irisowner@b01d34432e99"
		set ^SYS("SourceControl","Git","settings","user","irisowner","gitUserName")="irisowner"
	} catch e {
		set sc = e.AsStatus()
	}
	
	$$$ThrowOnError(sc)
}

ClassMethod SetupCodeTidy()
{
	do ##class(pkg.isc.codetidy.Utils).SetupExtension()
	set ^Config("CodeTidy", "brace") = 1
	set ^Config("CodeTidy", "capital") = 0
	set ^Config("CodeTidy", "codetidy") = 1
	set ^Config("CodeTidy", "coscomment") = "//"
	set ^Config("CodeTidy", "coswhitespace") = 1
	set ^Config("CodeTidy", "eslintenabled") = 1
	set ^Config("CodeTidy", "formatonsave") = 1
	set ^Config("CodeTidy", "indent") = 1
	set ^Config("CodeTidy", "indentString") = $char(9)
	set ^Config("CodeTidy", "indentglobal") = 1
	set ^Config("CodeTidy", "indentstringglobal") = $char(9)
	set ^Config("CodeTidy", "resequence") = 1
	set ^Config("CodeTidy", "sqlcase") = ""
	set ^Config("CodeTidy", "sqlplan") = 0
	set ^Config("CodeTidy", "tweak") = "warn"
	set ^Config("CodeTidy", "usemacrocomments") = 0
}

ClassMethod AddCodeDBReadForStaticFiles(webApplication As %String, roleName As %String)
{
	set oldNS = $namespace
	new $namespace
	set $namespace = "%SYS"
	
	// Find the namespace-default routine DB
	$$$ThrowOnError(##class(Config.Namespaces).Get(oldNS, .nsProps))
	set defaultDB = nsProps("Routines")
	$$$ThrowOnError(##class(Config.Databases).Get(defaultDB, .dbProps))
	set db = ##class(SYS.Database).%OpenId(dbProps("Directory"), , .sc)
	$$$ThrowOnError(sc)
	set dbResource = db.ResourceName

	// Is there public READ permission on the namespace-default routine DB?
	$$$ThrowOnError(##class(Security.Resources).Get(dbResource, .resourceProps))
	if (resourceProps("PublicPermission") # 2) {
		// No need to do anything else if there's public R permission
		quit
	}

	// Create role granting R permission on namespace-default routine DB resource
	// This is the least-access means to be able to use the REST handler class
	// in unauthenticated mode
	set roleProps("Description") = "Role granting only R permission on " _ dbResource
	set roleProps("Resources") = dbResource _ ":R"
	set roleProps("GrantedRoles") = ""
	if ##class(Security.Roles).Exists(roleName) {
		write !, "Updating role: ", roleName
		$$$ThrowOnError(##class(Security.Roles).Modify(roleName, .roleProps))
	} else {
		write !, "Creating role: ", roleName
		$$$ThrowOnError(##class(Security.Roles).Create(roleName, roleProps("Description"), roleProps("Resources"), roleProps("GrantedRoles")))
	}
	$$$ThrowOnError(##class(Security.Applications).Get(webApplication, .props))
	set props("MatchRoles") = ":" _ roleName
	$$$ThrowOnError(##class(Security.Applications).Modify(webApplication, .props))
}

}
