Include %sySecurity

Class AngularTemplate.Installer
{

Parameter RoleName = "AngularTemplate";

/// Manifest Definition.
XData MyManifest [ XMLNamespace = INSTALLER ]
{
<Manifest>

<Var Name="Namespace" Value="angular-template"/>
<If Condition='##class(%File).DirectoryExists("/database")'>
<Var Name="CodeDBDir" Value="/database/${Namespace}-CODE/"/>
<Var Name="DataDBDir" Value="/database/${Namespace}-DATA/"/>
<Var Name="ConfigDBDir" Value="/database/${Namespace}-CONFIG/"/>
<Else>
<Var Name="CodeDBDir" Value="${MGRDIR}${Namespace}-CODE/"/>
<Var Name="DataDBDir" Value="${MGRDIR}${Namespace}-DATA/"/>
<Var Name="ConfigDBDir" Value="${MGRDIR}${Namespace}-CONFIG/"/>
</Else>
</If>

<!-- Initialize databases -->
<Namespace Name="${SourceNamespace}" Create="no">
<If Condition='##class(%File).DirectoryExists("${CodeDBDir}")'>
<Database Name="${Namespace}-CODE" Dir="${CodeDBDir}" Create="no" InitialSize="10" ExpansionSize="10" />
<Else>
<Database Name="${Namespace}-CODE" Dir="${CodeDBDir}" Create="yes" InitialSize="10" ExpansionSize="10" />
</Else>
</If>
<If Condition='##class(%File).DirectoryExists("${DataDBDir}")'>
<Database Name="${Namespace}-DATA" Dir="${DataDBDir}" Create="no" InitialSize="10" ExpansionSize="10" />
<Else>
<Database Name="${Namespace}-DATA" Dir="${DataDBDir}" Create="yes" InitialSize="10" ExpansionSize="10" />
</Else>
</If>
<If Condition='##class(%File).DirectoryExists("${ConfigDBDir}")'>
<Database Name="${Namespace}-CONFIG" Dir="${ConfigDBDir}" Create="no" InitialSize="10" ExpansionSize="10" />
<Else>
<Database Name="${Namespace}-CONFIG" Dir="${ConfigDBDir}" Create="yes" InitialSize="10" ExpansionSize="10" />
</Else>
</If>
</Namespace>

<!-- Change data, code directories on namespace  -->
<Namespace Name="${Namespace}" Ensemble="0" Code="${Namespace}-CODE" Data="${Namespace}-DATA">
<Configuration>
<GlobalMapping Global="Config" From="${Namespace}-CONFIG" />
<GlobalMapping Global="Sources" From="${Namespace}-CONFIG" />
<GlobalMapping Global="SYS" From="${Namespace}-CONFIG" />
</Configuration>
</Namespace>

<Namespace Name="${SourceNamespace}" Create="no">

<!-- Install ZPM -->
<Invoke Class="AngularTemplate.Installer" Method="InstallZPM" />
</Namespace>

<Namespace Name="${Namespace}" Create="no">
<!-- ZPM load -->
<Invoke Class="AngularTemplate.Installer" Method="ZPMLoad" />
<Invoke Class="AngularTemplate.Installer" Method="SetupCodeTidy" />
</Namespace>

<Namespace Name="${SourceNamespace}" Create="no">

<!-- Configure Source Control -->
<!--<Invoke Class="AngularTemplate.Installer" Method="RunSourceControlSetup" />-->
</Namespace>
</Manifest>
}

ClassMethod SetupBASE()
{
	Set vars("Environment") = "BASE"
	Set vars("SourceNamespace") = $Namespace
	Do ..setup(.vars)
}

ClassMethod SetupTEST()
{
	Set vars("Environment") = "TEST"
	Set vars("SourceNamespace") = $Namespace
	Do ..setup(.vars)
}

ClassMethod SetupUAT()
{
	Set vars("Environment") = "UAT"
	Set vars("SourceNamespace") = $Namespace
	Do ..setup(.vars)
}

ClassMethod SetupLIVE()
{
	Set vars("Environment") = "LIVE"
	Set vars("SourceNamespace") = $Namespace
	Do ..setup(.vars)
}

/// This is a method generator whose code is generated by XGL.
ClassMethod setup(ByRef pVars, pLogLevel As %Integer = 3, pInstaller As %Installer.Installer, pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
	#; Let our XGL document generate code for this method.
	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "MyManifest")
}

ClassMethod InstallZPM(force As %Boolean = 0) As %Status
{
	If $$$comClassDefined("%ZPM.PackageManager") && 'force {
		Quit $$$OK
	}
	If $$$isUNIX {
		Do $zf(-100,"","mkdir","-p", "/tmp/deps")
		Do $zf(-100,"","wget","-q","https://pm.community.intersystems.com/packages/zpm/latest/installer","-O","/tmp/deps/zpm.xml")
		Set sc = $System.OBJ.Load("/tmp/deps/zpm.xml","ck")
	} Else {
		Do ##class(%File).CreateDirectoryChain("C:\Temp\")
		Do $zf(-100,"/STDOUT=""C:\Temp\zpm.xml""","curl","https://pm.community.intersystems.com/packages/zpm/latest/installer")
		Set sc = $System.OBJ.Load("C:\Temp\zpm.xml","ck")
	}
	Write !
	Quit sc
}

ClassMethod ZPMLoad()
{
	Set cmd = "load "_^Sources_" -dev -verbose"
	Write "zpm "_$$$QUOTE(cmd)
	Do ##class(%ZPM.PackageManager).Shell(cmd)
}

ClassMethod ToggleIRISLIBReadOnly(readOnly As %Boolean) As %Boolean
{
	If '$System.Security.Check($$$AdminManageResourceName,$$$PermUseName) {
		// No-op; let the user do whatever their current permissions happen to allow, rather than definitely failing at this stage.
		Quit readOnly
	}

	Set return = readOnly
	Set directory = ##class(%SYS.Namespace).GetPackageDest($Namespace,"%Studio")
	New $Namespace
	Set $Namespace = "%SYS"
	Set database = ##class(SYS.Database).%OpenId($Piece(directory,"^",2),,.tSC)
	$$$ThrowOnError(tSC)
	If (database.ReadOnly '= readOnly) {
		Set return = database.ReadOnly
		Set database.ReadOnly = readOnly
		$$$ThrowOnError(database.%Save())
	}
	Quit return
}

ClassMethod SetCSSToUTF8()
{
    Write !,"Setting:",
        "^%SYS(""CSP"",""MimeFileClassify"",""CSS"")=$lb(""text/css"",0,""utf-8"")",
        "^%SYS(""CSP"",""MimeFileClassify"",""HTML"")=$lb(""text/html"",0,""utf-8"")",
        "^%SYS(""CSP"",""MimeFileClassify"",""JS"")=$lb(""application/javascript"",0,""utf-8"")"
    Set ^%SYS("CSP","MimeFileClassify","CSS")=$lb("text/css",0,"utf-8")
    Set ^%SYS("CSP","MimeFileClassify","HTML")=$lb("text/html",0,"utf-8")
    Set ^%SYS("CSP","MimeFileClassify","JS")=$lb("application/javascript",0,"utf-8")
}

ClassMethod ApplySecurityChanges(webApplication As %String, roleName As %String = {..#RoleName})
{
    Set oldNS = $Namespace
    New $Namespace
    Set $Namespace = "%SYS"
    
    // Find the namespace-default routine DB
    Set grantPermissions = ""
    $$$ThrowOnError(##class(Config.Namespaces).Get(oldNS,.nsProps))
    For defaultDB = nsProps("Routines"),nsProps("Globals") {
        $$$ThrowOnError(##class(Config.Databases).Get(defaultDB,.dbProps))
        Set db=##Class(SYS.Database).%OpenId(dbProps("Directory"),,.sc)
        $$$ThrowOnError(sc)
        If $Get(dbResource) = db.ResourceName {
            // On second iteration, found same database
            // Reset grantPermissions
            Set grantPermissions = ""
        }
        Set dbResource = db.ResourceName

        // Is there public READ permission on the namespace-default routine DB?
        $$$ThrowOnError(##class(Security.Resources).Get(dbResource,.resourceProps))
        Set grantPermission = $Case(defaultDB,nsProps("Globals"):"RW",:"R")
        If $Data(resourceProps("PublicPermission"),publicPermission)#2 && (publicPermission [ grantPermission) {
            // No need to do anything else if there's public R permission
            Continue
        }
        Set grantPermissions = grantPermissions_$ListBuild(dbResource_":"_grantPermission)
    }

    If grantPermissions = "" {
        Quit
    }

    // Create role granting R permission on namespace-default routine DB resource
    // This is the least-access means to be able to use the REST handler class
    // in unauthenticated mode
    Set roleProps("Description") = "Role granting "_$ListToString(grantPermissions," and ")
    Set roleProps("Resources") = $ListToString(grantPermissions)
    Set roleProps("GrantedRoles") = ""
    If ##class(Security.Roles).Exists(roleName) {
        Write !,"Updating role: ",roleName
        $$$ThrowOnError(##class(Security.Roles).Modify(roleName,.roleProps))
    } Else {
        Write !,"Creating role: ",roleName
        $$$ThrowOnError(##class(Security.Roles).Create(roleName,roleProps("Description"),roleProps("Resources"),roleProps("GrantedRoles")))
    }
    $$$ThrowOnError(##class(Security.Applications).Get(webApplication,.props))
    Set props("MatchRoles")=":"_roleName
    $$$ThrowOnError(##class(Security.Applications).Modify(webApplication,.props))
}

ClassMethod RemoveSecurityChanges(roleName As %String = {..#RoleName})
{
    Set oldNS = $Namespace
    New $Namespace
    Set $Namespace = "%SYS"
    
    Try {
        If ##class(Security.Roles).Exists(roleName) {
            Write !,"Removing role: ",roleName
            $$$ThrowOnError(##class(Security.Roles).Delete(roleName))
        }
    } Catch e {
        Write !,"Error occurred cleaning up security objects: "
        Write $System.Status.GetErrorText(e.AsStatus())
    }
}

ClassMethod RunSourceControlSetup(namespace As %String = {$Namespace}, environment As %String = "BASE", sourceNamespace As %String = {$Namespace})
{
	Set sc = $$$OK
	
	// Copy this class to the target namespace
	If (sourceNamespace '= namespace) {
		Merge ^|namespace|oddDEF($classname()) = ^oddDEF($classname())
	}
	
	
	Try {
		New $Namespace
		Set $Namespace = namespace
		If (sourceNamespace '= namespace) {
			$$$ThrowOnError($System.OBJ.Compile($classname(),"ck-d"))
		}

		// Make IRISLIB R/W; need to leave it this way for JSON compilation...
		Set old = ..ToggleIRISLIBReadOnly(0)
		
        // Set up source control
        d ##class(SourceControl.Git.API).Configure()
	} Catch e {
		Set sc = e.AsStatus()
	}

	
	$$$ThrowOnError(sc)
}

ClassMethod SetupCodeTidy() {
	do ##class(pkg.isc.codetidy.Utils).SetupExtension()
	set ^Config("CodeTidy","formatonsave") = 1
	set ^Config("CodeTidy","resequence") = 1
	set ^Config("CodeTidy","indentglobal") = 1
	set ^Config("CodeTidy","indentstringglobal") = $c(9)
	set ^Config("CodeTidy","tweak") = "warn"
	set ^Config("CodeTidy","codetidy") = 0
	set ^Config("CodeTidy","usemacrocomments") = 0
	set ^Config("CodeTidy","eslintenabled") = 1
}

ClassMethod AddCodeDBReadForStaticFiles(webApplication As %String, roleName As %String)
{
    Set oldNS = $Namespace
    New $Namespace
    Set $Namespace = "%SYS"
    
    // Find the namespace-default routine DB
    $$$ThrowOnError(##class(Config.Namespaces).Get(oldNS,.nsProps))
    Set defaultDB = nsProps("Routines")
    $$$ThrowOnError(##class(Config.Databases).Get(defaultDB,.dbProps))
    Set db=##Class(SYS.Database).%OpenId(dbProps("Directory"),,.sc)
    $$$ThrowOnError(sc)
    Set dbResource = db.ResourceName

    // Is there public READ permission on the namespace-default routine DB?
    $$$ThrowOnError(##class(Security.Resources).Get(dbResource,.resourceProps))
    If (resourceProps("PublicPermission")#2) {
        // No need to do anything else if there's public R permission
        Quit
    }

    // Create role granting R permission on namespace-default routine DB resource
    // This is the least-access means to be able to use the REST handler class
    // in unauthenticated mode
    Set roleProps("Description") = "Role granting only R permission on "_dbResource
    Set roleProps("Resources") = dbResource_":R"
    Set roleProps("GrantedRoles") = ""
    If ##class(Security.Roles).Exists(roleName) {
        Write !,"Updating role: ",roleName
        $$$ThrowOnError(##class(Security.Roles).Modify(roleName,.roleProps))
    } Else {
        Write !,"Creating role: ",roleName
        $$$ThrowOnError(##class(Security.Roles).Create(roleName,roleProps("Description"),roleProps("Resources"),roleProps("GrantedRoles")))
    }
    $$$ThrowOnError(##class(Security.Applications).Get(webApplication,.props))
    Set props("MatchRoles")=":"_roleName
    $$$ThrowOnError(##class(Security.Applications).Modify(webApplication,.props))
}

}

